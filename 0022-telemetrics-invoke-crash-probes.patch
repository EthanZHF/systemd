From 047d8c21481b99804f10c5d56d58016c59bdbf9a Mon Sep 17 00:00:00 2001
From: Dimitri John Ledkov <dimitri.j.ledkov@intel.com>
Date: Fri, 10 Jul 2015 16:24:47 +0100
Subject: [PATCH 22/30] telemetrics: invoke crash-probes.

---
 src/basic/util.c | 106 ++++++++++++++++++++++++++++++++++++++++++-------------
 src/basic/util.h |   5 +++
 2 files changed, 87 insertions(+), 24 deletions(-)

diff --git a/src/basic/util.c b/src/basic/util.c
index 58617b3..fc2a80b 100644
--- a/src/basic/util.c
+++ b/src/basic/util.c
@@ -71,6 +71,7 @@
 
 #include "alloc-util.h"
 #include "build.h"
+#include "copy.h"
 #include "def.h"
 #include "device-nodes.h"
 #include "dirent-util.h"
@@ -125,11 +126,73 @@ size_t page_size(void) {
         return pgsz;
 }
 
-static int do_execute(char **directories, usec_t timeout, char *argv[]) {
+int do_cmd_popen(char *argv[], const void *data, pid_t *pid) {
+        int r;
+        FILE *p;
+        int pfd;
+        struct stat st;
+        int *fd = (int *)data;
+        _cleanup_free_ char *contents = NULL;
+        _cleanup_free_ char *args = NULL;
+
+        assert(fd);
+        assert(*fd >= 0);
+
+        if (lseek(*fd, 0, SEEK_SET) < 0)
+                return -errno;
+
+        if (fstat(*fd, &st) < 0)
+                return -errno;
+
+        /* ask caller not to wait - run synchronously. */
+        *pid = 0;
+
+        args = strv_join(argv, " ");
+
+        errno = 0;
+        p = popen (args, "w");
+        if (!p) {
+                if (!errno) errno = -ENOMEM;
+                return log_error_errno(errno, "Failed to popen: %m");
+        }
+
+        pfd = fileno(p);
+
+        r = copy_bytes(*fd, pfd, st.st_size, false);
+        if (r < 0) {
+                pclose(p);
+                log_error_errno(r, "Failed to pass coredump to handler: %m");
+        }
+
+        pclose(p);
+
+        return 0;
+}
+
+static int do_cmd_exec(char *argv[], const void *data, pid_t *pid) {
+        *pid = fork();
+        if (*pid < 0) {
+                return log_error_errno(errno, "Failed to fork: %m");
+        } else if (*pid == 0) {
+                assert_se(prctl(PR_SET_PDEATHSIG, SIGTERM) == 0);
+
+                execv(argv[0], argv);
+                return log_error_errno(errno, "Failed to execute %s: %m", argv[0]);
+        }
+
+        return 0;
+}
+
+// Iterate through the specified directories and run the provided
+// handler on each file found.
+static int do_iterate_dirs(char **directories, usec_t timeout, char *argv[],
+        iterate_file_handler handler, const void *data) {
         _cleanup_hashmap_free_free_ Hashmap *pids = NULL;
         _cleanup_set_free_free_ Set *seen = NULL;
         char **directory;
 
+        assert (handler);
+
         /* We fork this all off from a child process so that we can
          * somewhat cleanly make use of SIGALRM to set a time limit */
 
@@ -184,31 +247,20 @@ static int do_execute(char **directories, usec_t timeout, char *argv[]) {
                                 continue;
                         }
 
-                        pid = fork();
-                        if (pid < 0) {
-                                log_error_errno(errno, "Failed to fork: %m");
-                                continue;
-                        } else if (pid == 0) {
-                                char *_argv[2];
+                        /* Replace the placeholder value */
+                        argv[0] = path;
 
-                                assert_se(prctl(PR_SET_PDEATHSIG, SIGTERM) == 0);
+                        r = handler(argv, data, &pid);
+                        if (r < 0)
+                                return r;
 
-                                if (!argv) {
-                                        _argv[0] = path;
-                                        _argv[1] = NULL;
-                                        argv = _argv;
-                                } else
-                                        argv[0] = path;
+                        if (pid) {
+                                log_debug("Spawned %s as " PID_FMT ".", path, pid);
 
-                                execv(path, argv);
-                                return log_error_errno(errno, "Failed to execute %s: %m", path);
+                                r = hashmap_put(pids, UINT_TO_PTR(pid), path);
+                                if (r < 0)
+                                        return log_oom();
                         }
-
-                        log_debug("Spawned %s as " PID_FMT ".", path, pid);
-
-                        r = hashmap_put(pids, PID_TO_PTR(pid), path);
-                        if (r < 0)
-                                return log_oom();
                         path = NULL;
                 }
         }
@@ -236,7 +288,8 @@ static int do_execute(char **directories, usec_t timeout, char *argv[]) {
         return 0;
 }
 
-void execute_directories(const char* const* directories, usec_t timeout, char *argv[]) {
+void iterate_directories(const char* const* directories, usec_t timeout,
+        char *argv[], iterate_file_handler handler, const void *data) {
         pid_t executor_pid;
         int r;
         char *name;
@@ -258,13 +311,18 @@ void execute_directories(const char* const* directories, usec_t timeout, char *a
                 return;
 
         } else if (executor_pid == 0) {
-                r = do_execute(dirs, timeout, argv);
+                r = do_iterate_dirs(dirs, timeout, argv, handler, data);
                 _exit(r < 0 ? EXIT_FAILURE : EXIT_SUCCESS);
         }
 
         wait_for_terminate_and_warn(name, executor_pid, true);
 }
 
+void execute_directories(const char* const* directories, usec_t timeout, char *argv[]) {
+        return iterate_directories(directories, timeout, argv, do_cmd_exec, NULL);
+}
+
+
 bool plymouth_running(void) {
         return access("/run/plymouth/pid", F_OK) >= 0;
 }
diff --git a/src/basic/util.h b/src/basic/util.h
index d9d2f72..3c94bf4 100644
--- a/src/basic/util.h
+++ b/src/basic/util.h
@@ -59,7 +59,12 @@ static inline const char* one_zero(bool b) {
         return b ? "1" : "0";
 }
 
+typedef int (*iterate_file_handler) (char *argv[], const void *data, pid_t *pid);
+
 void execute_directories(const char* const* directories, usec_t timeout, char *argv[]);
+void iterate_directories(const char* const* directories, usec_t timeout, char *argv[],
+        iterate_file_handler handler, const void *data);
+int do_cmd_popen(char *argv[], const void *data, pid_t *pid);
 
 bool plymouth_running(void);
 
-- 
2.8.1

