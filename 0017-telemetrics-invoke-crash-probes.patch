From 66e0f8c780754353fa253be572fb0708db33ea7c Mon Sep 17 00:00:00 2001
From: Dimitri John Ledkov <dimitri.j.ledkov@intel.com>
Date: Fri, 10 Jul 2015 16:24:47 +0100
Subject: [PATCH 17/28] telemetrics: invoke crash-probes.

---
 src/basic/util.c | 106 ++++++++++++++++++++++++++++++++++++++++++-------------
 src/basic/util.h |   5 +++
 2 files changed, 86 insertions(+), 25 deletions(-)

diff --git a/src/basic/util.c b/src/basic/util.c
index ea1bed7..e42835e 100644
--- a/src/basic/util.c
+++ b/src/basic/util.c
@@ -36,6 +36,7 @@
 
 #include "alloc-util.h"
 #include "build.h"
+#include "copy.h"
 #include "def.h"
 #include "dirent-util.h"
 #include "fd-util.h"
@@ -78,11 +79,73 @@ size_t page_size(void) {
         return pgsz;
 }
 
-static int do_execute(char **directories, usec_t timeout, char *argv[]) {
+int do_cmd_popen(char *argv[], const void *data, pid_t *pid) {
+        int r;
+        FILE *p;
+        int pfd;
+        struct stat st;
+        int *fd = (int *)data;
+        _cleanup_free_ char *contents = NULL;
+        _cleanup_free_ char *args = NULL;
+
+        assert(fd);
+        assert(*fd >= 0);
+
+        if (lseek(*fd, 0, SEEK_SET) < 0)
+                return -errno;
+
+        if (fstat(*fd, &st) < 0)
+                return -errno;
+
+        /* ask caller not to wait - run synchronously. */
+        *pid = 0;
+
+        args = strv_join(argv, " ");
+
+        errno = 0;
+        p = popen (args, "w");
+        if (!p) {
+                if (!errno) errno = -ENOMEM;
+                return log_error_errno(errno, "Failed to popen: %m");
+        }
+
+        pfd = fileno(p);
+
+        r = copy_bytes(*fd, pfd, st.st_size, false);
+        if (r < 0) {
+                pclose(p);
+                log_error_errno(r, "Failed to pass coredump to handler: %m");
+        }
+
+        pclose(p);
+
+        return 0;
+}
+
+static int do_cmd_exec(char *argv[], const void *data, pid_t *pid) {
+        *pid = fork();
+        if (*pid < 0) {
+                return log_error_errno(errno, "Failed to fork: %m");
+        } else if (*pid == 0) {
+                assert_se(prctl(PR_SET_PDEATHSIG, SIGTERM) == 0);
+
+                execv(argv[0], argv);
+                return log_error_errno(errno, "Failed to execute %s: %m", argv[0]);
+        }
+
+        return 0;
+}
+
+// Iterate through the specified directories and run the provided
+// handler on each file found.
+static int do_iterate_dirs(char **directories, usec_t timeout, char *argv[],
+        iterate_file_handler handler, const void *data) {
         _cleanup_hashmap_free_free_ Hashmap *pids = NULL;
         _cleanup_set_free_free_ Set *seen = NULL;
         char **directory;
 
+        assert (handler);
+
         /* We fork this all off from a child process so that we can
          * somewhat cleanly make use of SIGALRM to set a time limit */
 
@@ -137,31 +200,19 @@ static int do_execute(char **directories, usec_t timeout, char *argv[]) {
                                 continue;
                         }
 
-                        pid = fork();
-                        if (pid < 0) {
-                                log_error_errno(errno, "Failed to fork: %m");
-                                continue;
-                        } else if (pid == 0) {
-                                char *_argv[2];
-
-                                assert_se(prctl(PR_SET_PDEATHSIG, SIGTERM) == 0);
+                        /* Replace the placeholder value */
+                        argv[0] = path;
 
-                                if (!argv) {
-                                        _argv[0] = path;
-                                        _argv[1] = NULL;
-                                        argv = _argv;
-                                } else
-                                        argv[0] = path;
-
-                                execv(path, argv);
-                                return log_error_errno(errno, "Failed to execute %s: %m", path);
+                        r = handler(argv, data, &pid);
+                        if (r < 0)
+                                return r;
+                        if (pid) {
+                                log_debug("Spawned %s as " PID_FMT ".", path, pid);
+                                r = hashmap_put(pids, UINT_TO_PTR(pid), path);
+                                if (r < 0)
+                                        return log_oom();
                         }
 
-                        log_debug("Spawned %s as " PID_FMT ".", path, pid);
-
-                        r = hashmap_put(pids, PID_TO_PTR(pid), path);
-                        if (r < 0)
-                                return log_oom();
                         path = NULL;
                 }
         }
@@ -189,7 +240,8 @@ static int do_execute(char **directories, usec_t timeout, char *argv[]) {
         return 0;
 }
 
-void execute_directories(const char* const* directories, usec_t timeout, char *argv[]) {
+void iterate_directories(const char* const* directories, usec_t timeout,
+        char *argv[], iterate_file_handler handler, const void *data) {
         pid_t executor_pid;
         int r;
         char *name;
@@ -211,13 +263,17 @@ void execute_directories(const char* const* directories, usec_t timeout, char *a
                 return;
 
         } else if (executor_pid == 0) {
-                r = do_execute(dirs, timeout, argv);
+                r = do_iterate_dirs(dirs, timeout, argv, handler, data);
                 _exit(r < 0 ? EXIT_FAILURE : EXIT_SUCCESS);
         }
 
         wait_for_terminate_and_warn(name, executor_pid, true);
 }
 
+void execute_directories(const char* const* directories, usec_t timeout, char *argv[]) {
+        return iterate_directories(directories, timeout, argv, do_cmd_exec, NULL);
+}
+
 bool plymouth_running(void) {
         return access("/run/plymouth/pid", F_OK) >= 0;
 }
diff --git a/src/basic/util.h b/src/basic/util.h
index 6f42c85..04a9cd2 100644
--- a/src/basic/util.h
+++ b/src/basic/util.h
@@ -60,7 +60,12 @@ static inline const char* one_zero(bool b) {
         return b ? "1" : "0";
 }
 
+typedef int (*iterate_file_handler) (char *argv[], const void *data, pid_t *pid);
+
 void execute_directories(const char* const* directories, usec_t timeout, char *argv[]);
+void iterate_directories(const char* const* directories, usec_t timeout, char *argv[],
+        iterate_file_handler handler, const void *data);
+int do_cmd_popen(char *argv[], const void *data, pid_t *pid);
 
 bool plymouth_running(void);
 
-- 
2.9.0

